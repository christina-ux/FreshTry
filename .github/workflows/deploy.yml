name: Deploy to AWS ECS

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BASE: policyedgeai
  ECS_CLUSTER_PREFIX: PolicyEdgeAI-Cluster
  API_SERVICE_PREFIX: policyedgeai-api-service
  DASHBOARD_SERVICE_PREFIX: policyedgeai-dashboard-service
  API_CONTAINER_NAME: api-container
  DASHBOARD_CONTAINER_NAME: dashboard-container
  PYTHON_VERSION: '3.9'

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio flake8 mypy
      
      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --statistics
      
      - name: Type check with mypy
        run: |
          mypy --ignore-missing-imports --disallow-untyped-defs --disallow-incomplete-defs .
      
      - name: Run tests with pytest
        run: |
          pytest --cov=./ --cov-report=xml
      
      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: false

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          fi
          echo "API_ECR_REPOSITORY=${ECR_REPOSITORY_BASE}-api" >> $GITHUB_ENV
          echo "DASHBOARD_ECR_REPOSITORY=${ECR_REPOSITORY_BASE}-dashboard" >> $GITHUB_ENV
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
          echo "ECS_CLUSTER=${ECS_CLUSTER_PREFIX}-${ENVIRONMENT}" >> $GITHUB_ENV
          echo "API_SERVICE=${API_SERVICE_PREFIX}-${ENVIRONMENT}" >> $GITHUB_ENV
          echo "DASHBOARD_SERVICE=${DASHBOARD_SERVICE_PREFIX}-${ENVIRONMENT}" >> $GITHUB_ENV
          echo "COMMIT_HASH=${GITHUB_SHA:0:8}" >> $GITHUB_ENV
          echo "GITHUB_REPOSITORY_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Check if ECR repositories exist
        id: check-ecr
        run: |
          repos=$(aws ecr describe-repositories --repository-names ${{ env.API_ECR_REPOSITORY }} ${{ env.DASHBOARD_ECR_REPOSITORY }} --query 'repositories[*].repositoryName' --output text 2>/dev/null || echo "")
          if [[ $repos != *"${{ env.API_ECR_REPOSITORY }}"* ]]; then
            aws ecr create-repository --repository-name ${{ env.API_ECR_REPOSITORY }} --image-scanning-configuration scanOnPush=true
            echo "Created API ECR repository"
          fi
          if [[ $repos != *"${{ env.DASHBOARD_ECR_REPOSITORY }}"* ]]; then
            aws ecr create-repository --repository-name ${{ env.DASHBOARD_ECR_REPOSITORY }} --image-scanning-configuration scanOnPush=true
            echo "Created Dashboard ECR repository"
          fi
      
      # Build and push API image with concurrent steps
      - name: Build API image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./api.Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.API_ECR_REPOSITORY }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.API_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GITHUB_SHA=${{ github.sha }}
            GITHUB_REF=${{ github.ref }}
            BUILD_DATE=${{ env.BUILD_DATE }}
            GITHUB_REPOSITORY_OWNER=${{ env.GITHUB_REPOSITORY_OWNER }}
      
      # Build and push Dashboard image concurrently
      - name: Build Dashboard image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./dashboard.Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.DASHBOARD_ECR_REPOSITORY }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.DASHBOARD_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GITHUB_SHA=${{ github.sha }}
            GITHUB_REF=${{ github.ref }}
            BUILD_DATE=${{ env.BUILD_DATE }}
            GITHUB_REPOSITORY_OWNER=${{ env.GITHUB_REPOSITORY_OWNER }}
      
      # Update API task definition with concurrent processing
      - name: Download API task definition
        run: |
          aws ecs describe-task-definition --task-definition policyedgeai-api-task-${{ env.ENVIRONMENT }} --query taskDefinition > api-task-definition.json
      
      - name: Update API container image
        id: render-api-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: api-task-definition.json
          container-name: ${{ env.API_CONTAINER_NAME }}
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.API_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}
      
      - name: Deploy API to Amazon ECS
        id: deploy-api
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-api-container.outputs.task-definition }}
          service: ${{ env.API_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
      
      # Update Dashboard task definition in parallel
      - name: Download Dashboard task definition
        run: |
          aws ecs describe-task-definition --task-definition policyedgeai-dashboard-task-${{ env.ENVIRONMENT }} --query taskDefinition > dashboard-task-definition.json
      
      - name: Update Dashboard container image
        id: render-dashboard-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: dashboard-task-definition.json
          container-name: ${{ env.DASHBOARD_CONTAINER_NAME }}
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.DASHBOARD_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}
      
      - name: Deploy Dashboard to Amazon ECS
        id: deploy-dashboard
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-dashboard-container.outputs.task-definition }}
          service: ${{ env.DASHBOARD_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
      
      # Verify deployment
      - name: Verify deployment
        run: |
          echo "Verifying API deployment..."
          aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.API_SERVICE }} --query 'services[0].deployments[0].status'
          
          echo "Verifying Dashboard deployment..."
          aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.DASHBOARD_SERVICE }} --query 'services[0].deployments[0].status'
          
          API_TASKS=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.API_SERVICE }} --query 'taskArns' --output text)
          DASHBOARD_TASKS=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.DASHBOARD_SERVICE }} --query 'taskArns' --output text)
          
          echo "API Tasks: $API_TASKS"
          echo "Dashboard Tasks: $DASHBOARD_TASKS"
          
          # Check task health
          for task in $API_TASKS; do
            echo "Checking health of API task $task"
            aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $task --query 'tasks[0].healthStatus'
          done
          
          for task in $DASHBOARD_TASKS; do
            echo "Checking health of Dashboard task $task"
            aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $task --query 'tasks[0].healthStatus'
          done
      
      # Create git tag for deployment
      - name: Create deployment tag
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git tag "deployment-${{ env.ENVIRONMENT }}-${{ env.COMMIT_HASH }}" -m "Deployed to ${{ env.ENVIRONMENT }} on $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          git push origin "deployment-${{ env.ENVIRONMENT }}-${{ env.COMMIT_HASH }}"
      
      # Generate deployment summary
      - name: Generate deployment summary
        id: deployment-summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "Environment: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "API Image: ${{ steps.login-ecr.outputs.registry }}/${{ env.API_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}" >> $GITHUB_STEP_SUMMARY
          echo "Dashboard Image: ${{ steps.login-ecr.outputs.registry }}/${{ env.DASHBOARD_ECR_REPOSITORY }}:${{ env.COMMIT_HASH }}" >> $GITHUB_STEP_SUMMARY
          echo "API Task Definition: ${{ steps.deploy-api.outputs.task-definition-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "Dashboard Task Definition: ${{ steps.deploy-dashboard.outputs.task-definition-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "Deployed at: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_STEP_SUMMARY
          
          # Get application endpoints
          API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name PolicyEdgeAI-${{ env.ENVIRONMENT }} --query "Stacks[0].Outputs[?OutputKey=='APIEndpoint'].OutputValue" --output text || echo "N/A")
          DASHBOARD_ENDPOINT=$(aws cloudformation describe-stacks --stack-name PolicyEdgeAI-${{ env.ENVIRONMENT }} --query "Stacks[0].Outputs[?OutputKey=='DashboardEndpoint'].OutputValue" --output text || echo "N/A")
          MAIN_ENDPOINT=$(aws cloudformation describe-stacks --stack-name PolicyEdgeAI-${{ env.ENVIRONMENT }} --query "Stacks[0].Outputs[?OutputKey=='MainWebsiteEndpoint'].OutputValue" --output text || echo "N/A")
          
          echo "## Application Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "API: $API_ENDPOINT" >> $GITHUB_STEP_SUMMARY
          echo "Dashboard: $DASHBOARD_ENDPOINT" >> $GITHUB_STEP_SUMMARY
          echo "Main Website: $MAIN_ENDPOINT" >> $GITHUB_STEP_SUMMARY

  monitor:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.build-and-deploy.result }}" != "success" ]; then
            echo "::error::Deployment failed. Check the build-and-deploy job for details."
            exit 1
          fi
          echo "Deployment successful!"
      
      - name: Send Slack notification
        if: always() && secrets.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Deployment ${{ needs.build-and-deploy.result == 'success' && 'Succeeded' || 'Failed' }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n${{ github.sha }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\n${{ env.ENVIRONMENT }}"
                    },
                    {
                      "type": "mrkdwn", 
                      "text": "*Deployed by:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n${{ needs.build-and-deploy.result == 'success' && '✅ Success' || '❌ Failed' }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow"
                      },
                      "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button", 
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit"
                      },
                      "url": "https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK